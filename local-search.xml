<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Deepin V20科学上网方法</title>
    <link href="/Blog.github.io/2021/07/28/deepin-V20%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <url>/Blog.github.io/2021/07/28/deepin-V20%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h2 id="关于-deepin-V20"><a href="#关于-deepin-V20" class="headerlink" title="关于 deepin V20"></a>关于 deepin V20</h2><p>其实本来在大一的时候就知道了deepin，那个时候还是在deepin 15.2的时代，本着支持国产的信念用了一年半，然后还是回到了Windows的怀抱，国产桌面系统的道路还是很长呀。转眼都到研究生了，课题组的电脑反正也不常用，就瞎捣鼓成linux，也方便学习linux的操作</p><p>虽然装过挺多的linux发行版，但是如果要我留一个的话必定是Deepin，理由就一个，不用到处搜教程装各种必须要用的软件实在太省心了，而且我觉得deepin v20已经有了自己的设计语言，当然也有许多人觉得它的标题栏特别宽，而且果味十足，不过我反正觉得颜值挺好的，就是bug能再少点就好了。</p><p><img src="https://gitee.com/flyieen/image/raw/master/deepin/deein-screenshot.png"></p><h2 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h2><h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><p>如果你的需求就是上github的话，那不用科学上网都可，Linux环境即便你没走代理，通过修改hosts配置文件一样可以登录，该方法亲测有效。</p><p>首先第一次使用时先打开终端命令修改root权限密码：</p><p>在终端命令下输入以下代码，并按照提示修改密码。密码一共要输入三次，此时终端里不会显示，输入完了回车即可：</p><p>su root passwd</p><p>修改好密码后输入以下命令，进入终端内的文本编辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo vi /etc/hosts<br></code></pre></td></tr></table></figure><p>修改好密码后输入以下命令，进入终端内的文本编辑：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vi <span class="hljs-regexp">/etc/</span>hosts<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text"># GitHub Start 140.82.113.3 github.com 140.82.114.20 gist.github.com 151.101.184.133 assets-cdn.github.com 151.101.184.133 raw.githubusercontent.com 151.101.184.133 gist.githubusercontent.com 151.101.184.133 cloud.githubusercontent.com 151.101.184.133 camo.githubusercontent.com 151.101.184.133 avatars0.githubusercontent.com 199.232.68.133 avatars0.githubusercontent.com 199.232.28.133 avatars1.githubusercontent.com 151.101.184.133 avatars1.githubusercontent.com 151.101.184.133 avatars2.githubusercontent.com 199.232.28.133 avatars2.githubusercontent.com 151.101.184.133 avatars3.githubusercontent.com 199.232.68.133 avatars3.githubusercontent.com 151.101.184.133 avatars4.githubusercontent.com 199.232.68.133 avatars4.githubusercontent.com 151.101.184.133 avatars5.githubusercontent.com 199.232.68.133 avatars5.githubusercontent.com 151.101.184.133 avatars6.githubusercontent.com 199.232.68.133 avatars6.githubusercontent.com 151.101.184.133 avatars7.githubusercontent.com 199.232.68.133 avatars7.githubusercontent.com 151.101.184.133 avatars8.githubusercontent.com 199.232.68.133 avatars8.githubusercontent.com # GitHub End<br></code></pre></td></tr></table></figure><p>然后按ESC退出insert模式，之后按：键进入命令模式，再输入wq 回车保存退出，然后你就可以正常访问Github了<br>（这里修改文件全程使用了vim编辑器，操作不明白的话可以搜一下vim怎么用，很简单，基本方法三分钟学完了)</p><h3 id="Qv2ray-软件"><a href="#Qv2ray-软件" class="headerlink" title="Qv2ray 软件"></a>Qv2ray 软件</h3><p>能够访问github后搜索Qv2ray，这里插一句，其实在windows环境下clash软件科学上网超级简单，但是Linux环境下配置就麻烦的多，这里就改用Qv2ray了。之后在release页面下载你电脑对应的软件包保存（一般都是下载v2ray-linux-64.zip这个包，即64位架构的，你是32位架构的就下32位那个）。方便起见我还是直接把<a href="https://github.com/Qv2ray/Qv2ray/releases">地址</a>贴在这里。这个是国人的appimage版本，如果你有appimage环境（例如deepin）就直接下载解压运行即可。deepin商店有appimage安装器，安装这个软件再安装这个也可以</p><p><img src="https://gitee.com/flyieen/image/raw/master/deepin/1.png"></p><p>然后再打开你买的代理服务，我使用的掠影网络!  然后复制对应的订阅链接</p><p><img src="https://gitee.com/flyieen/image/raw/master/deepin/2.png"></p><p>打开安装的Qv2ray，进入首选项面板，进去后将下面的Qv2ray代理选择成系统代理。</p><p><img src="https://gitee.com/flyieen/image/raw/master/deepin/%E6%88%AA%E5%9B%BE_qv2ray_20210728210156.png"></p><p>然后再到主界面的分组中的订阅设置面板，把上面复制的订阅链接填入，然后更新订阅，就可以再主界面看到默认分组下面有香港高速等选项</p><p><img src="https://gitee.com/flyieen/image/raw/master/deepin/%E6%88%AA%E5%9B%BE_qv2ray_20210728210629.png"></p><p>有人到了上面这里就可以正常连接了，但是可能还会出现“ V2Ray内核启动失败：找不到V2Ray核心可执行文件”  这个错误，这个错误是由于找不到V2Ray核心导致，所以我们还需要配置V2Ray Core，然后把它放到某个文件夹，然后自己再到内核设置面板设置一下即可</p><p>V2Ray Core 可以自行在github上搜索下载，</p><p><img src="https://gitee.com/flyieen/image/raw/master/deepin/%E6%88%AA%E5%9B%BE_qv2ray_20210728212332.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算</title>
    <link href="/Blog.github.io/2021/07/28/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/Blog.github.io/2021/07/28/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>主要就四种运算，分别是 &amp; 、| 和异或运算^以及移位运算&gt;&gt;，其中异或运算用的最多</p><p>0 s表示一串0，1 s表示一串1。</p><p>三种运算的基本规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">x ^ 0s = x      x &amp; 0s = 0      x | 0s = x<br>x ^ 1s = ~x     x &amp; 1s = x      x | 1s = 1s<br>x ^ x = 0       x &amp; x = x       x | x = x<br></code></pre></td></tr></table></figure><p>移位运算基本规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">a = <span class="hljs-number">111011</span><br>a &gt;&gt;= <span class="hljs-number">1</span> (表示向右移动一位，&gt;&gt;&gt;表示无符号右移,-<span class="hljs-number">7</span>右移动<span class="hljs-number">1</span>会变成<span class="hljs-number">3</span>，&gt;&gt;表示有符号右移) <br>a 的值变为 <span class="hljs-number">11101</span> <br></code></pre></td></tr></table></figure><h2 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h2><ol><li><strong>&amp; 运算符的进阶用法</strong></li></ol><p>(1)  如果有两个数字a与b，那么a&amp;b则表示和的那个进位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">a = <span class="hljs-number">01011011</span> &amp;<br>b = <span class="hljs-number">01011100</span> <br>c = <span class="hljs-number">10110000</span>   <span class="hljs-comment">// c 即表示a与b进行求和计算的所需的进位，可以配合a^b使用完成 a+b 的操作</span><br></code></pre></td></tr></table></figure><p>(2)  <em>n &amp; (n-1) 去除 n 的位级表示去除最低的那一位 1</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">01011011</span> &amp;<br><span class="hljs-number">01011010</span><br>--------<br><span class="hljs-number">01011010</span><br></code></pre></td></tr></table></figure><p><strong>注意：0 1 2 3 4 5 6… n 中每个数字二进制形式中1的个数有如下关系</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//例如：i = 6(110) 那么6有两个1  6(110) = 4(100) + 2(10)</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">i &amp; (i-1) 相当于去掉了最小位数的那个1 ，所以dp(i&amp;(i-1)) 必定比dp(i) 少一个1，所以符合下式</span><br><span class="hljs-comment">*/</span><br>dp(i) = dp(i&amp;(i-<span class="hljs-number">1</span>)) + <span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure><p>*实例：Leetcode 231. Power of Two (Easy)判断一个数是不是 2 的 n 次方 *</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;   <span class="hljs-comment">// 一个整数 2的0次方*系数+ 2的1次方*系数 + ... ，所以只有一个次方的系数为1，就是2的幂次方</span><br>    <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;   <br>    <span class="hljs-comment">// 1000 与 0111 的 &amp; 必为0，所以利用这条性质，当然也可以直接用return n &gt; 0 &amp;&amp; Integer.bitCount(n) == 1 做判断，效率还更高</span><br>&#125;<br><span class="hljs-comment">/* Leetcode 342 Power of Four (Easy)判断一个数是不是 2 的 n 次方</span><br><span class="hljs-comment">还有判断是否是4的幂次方，就是2的零次方，2的2次方，2的6次方啥的任意一个位置的系数为1，例如0010000，所以增加一个位次的判断即可</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">return</span> num &gt; <span class="hljs-number">0</span> &amp;&amp; (num &amp; (num - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span> &amp;&amp; (num &amp; <span class="hljs-number">0b01010101010101010101010101010101</span>) != <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>(3)  <em>n&amp;(-n) 得到 n 的位级表示中最低的那一位 1</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">10110100</span> &amp;<br><span class="hljs-number">01001100</span><br>--------<br><span class="hljs-number">00000100</span><br><span class="hljs-comment">// -n 得到 n 的反码加 1，也就是 -n=~n+1</span><br></code></pre></td></tr></table></figure><p>(4)  <em>实现掩码操作，利用 x &amp; 0 s = 0 和 x &amp; 1 s = x 的特点</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">01011011</span> &amp;<br><span class="hljs-number">00111100</span><br>--------<br><span class="hljs-number">00011000</span>   <br><span class="hljs-comment">//一个数 num 与 mask：00111100 进行位与操作，只保留 num 中与 mask 的 1 部分相对应的位。</span><br></code></pre></td></tr></table></figure><p>现在考虑掩码(mask)的计算方法:</p><p>1）只要11111111，将0取反即可，~0</p><p>2）要得到只有第i位置的mask，将1向左移动i-1位即可，1&lt;&lt;(i-1)。例如1&lt;&lt;4得到只有第五位为1的mask：00010000。</p><p>3）要得到1到i位为1的mask，（1&lt;&lt;i)-1即可，例如将 (1&lt;&lt;4)-1 = 00010000-1 = 00001111。</p><p>4）要得到1到i位为0的mask，只需将1到i位为1的mask取反，即 ~((1&lt;&lt;i)-1)。</p><ol start="2"><li><strong>| 运算符的进阶用法</strong></li><li><strong>^ 运算符的进阶用法</strong></li></ol><p>（1）如果有两个数字a和b，则a^b 则表示没有进行进位的a与b的和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">a = <span class="hljs-number">01011011</span> &amp;b = <span class="hljs-number">01011100</span> c = <span class="hljs-number">00000111</span>   <span class="hljs-comment">// 和 1中（1）的性质结合即可完成a+b 但是不使用 + 号的操作 </span><br></code></pre></td></tr></table></figure><p><em>实例： Leetcode 371. Sum of Two Integers (Easy)</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;    <br>    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : getSum((a ^ b), (a &amp; b) &lt;&lt; <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位,两个数相加即可得到结果，所以可以采用递归调用</span><br></code></pre></td></tr></table></figure><p>（2）利用 x ^ 1 s = ~x 的特点，可以将一个数的位级表示翻转；利用 x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>^<span class="hljs-number">1</span>^<span class="hljs-number">2</span> = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><em>实例1：Leetcode 136 找出数组中缺失的那个数</em></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">Input: [4,1,2,1,2]Output: 4<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">两个相同的数异或的结果为 <span class="hljs-number">0</span>，对所有数进行异或操作，最后的结果就是单独出现的那个数。<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;    <br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : nums) &#123;<br>        ret = ret ^ n;  <br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>实例2： Leetcode 260 数组中不重复的两个元素</em></p><p><strong>这题相比上题难在通过异或运算找出这两个数的异或结果后，怎么分开这两个数字</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">两个不相等的元素在位级表示上必定会有一位存在不同。<br><br>将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。<br><br>diff &amp;= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。<br>具体做法：<br>1.得到异或结果diff<br>2.创建两个组，a,b 为两个不重复数字，则将a,b分别分配到这两个组<br>3.将重复数字分配到同一组，接下来就是无脑^运算即可得到答案。<br>例如：<br>先得到diff = 3^5<br>[1,1,2,2,3,5] -&gt; [1,1,3] 和 [2,2,5]<br>随后两个组分别无脑^运算即可<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] singleNumber(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-keyword">int</span> diff = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) diff ^= num;<br>    diff &amp;= -diff;  <span class="hljs-comment">// 得到最右一位</span><br>    <span class="hljs-keyword">int</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>        <span class="hljs-keyword">if</span> ((num &amp; diff) == <span class="hljs-number">0</span>) ret[<span class="hljs-number">0</span>] ^= num;<br>        <span class="hljs-keyword">else</span> ret[<span class="hljs-number">1</span>] ^= num;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）不用第三个变量即可完成两个变量的值交换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">a = a ^ b;<br>b = a ^ b;<br>a = a ^ b;<br><br><span class="hljs-comment">// 还可以使用加减法实现</span><br>a = a + b;<br>b = a - b;<br>a = a - b;<br></code></pre></td></tr></table></figure><h2 id="综合使用"><a href="#综合使用" class="headerlink" title="综合使用"></a>综合使用</h2><ol><li><strong>Leetcode 461 Hamming Distance (Easy) 计算两个数的二进制表示有多少位不同</strong>*</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Input: x = <span class="hljs-number">1</span>, y = <span class="hljs-number">4</span><br>Output: <span class="hljs-number">2</span><br>Explanation:<br><span class="hljs-number">1</span>   (<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>)<br><span class="hljs-number">4</span>   (<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>)       <br>       ↑   ↑<br>The above arrows point to positions where the corresponding bits are different.<br></code></pre></td></tr></table></figure><p>对两个数进行异或操作，位级表示不同的那一位为 1，统计有多少个 1 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hammingDistance</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;    <br>    <span class="hljs-keyword">int</span> z = x ^ y;  <span class="hljs-comment">// 之后就是统计z的二进制形式中有多少个1    </span><br>    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;    <br>    <span class="hljs-keyword">while</span>(z != <span class="hljs-number">0</span>) &#123;        <br>        <span class="hljs-keyword">if</span> ((z &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) cnt++;  <span class="hljs-comment">// 判断最后一位是不是1        </span><br>        z = z &gt;&gt; <span class="hljs-number">1</span>;       <span class="hljs-comment">// 右移    </span><br>    &#125;    <br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>Leetcode 190 Reverse Bits (Easy) 翻转一个数的比特位</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;        <br>        ret &lt;&lt;= <span class="hljs-number">1</span>;        <br>        ret |= (n &amp; <span class="hljs-number">1</span>);        <br>        n &gt;&gt;&gt;= <span class="hljs-number">1</span>;    <br>    &#125;    <br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>Leetcode 476 Number Complement (Easy) 求一个数的补码</strong></li></ol><p>题目描述：不考虑二进制表示中的首 0 部分。对于 00000101，要求补码可以将它与 00000111 进行异或操作。那么问题就转换为求掩码 00000111。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">Input: 5<br>Output: 2<br>Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findComplement</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;    <br>    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <br>    <span class="hljs-keyword">int</span> mask = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;    <br>    <span class="hljs-keyword">while</span> ((num &amp; mask) == <span class="hljs-number">0</span>) <br>        mask &gt;&gt;= <span class="hljs-number">1</span>;    <br>    mask = (mask &lt;&lt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>;    <br>    <span class="hljs-keyword">return</span> num ^ mask;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 10000000 这样的数要扩展成 11111111，可以利用以下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">mask |= mask &gt;&gt; <span class="hljs-number">1</span>    <span class="hljs-number">11000000</span><br>mask |= mask &gt;&gt; <span class="hljs-number">2</span>    <span class="hljs-number">11110000</span><br>mask |= mask &gt;&gt; <span class="hljs-number">4</span>    <span class="hljs-number">11111111</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findComplement</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;    <br>    <span class="hljs-keyword">int</span> mask = num;    <br>    mask |= mask &gt;&gt; <span class="hljs-number">1</span>;    <br>    mask |= mask &gt;&gt; <span class="hljs-number">2</span>;    <br>    mask |= mask &gt;&gt; <span class="hljs-number">4</span>;    <br>    mask |= mask &gt;&gt; <span class="hljs-number">8</span>;   <br>    mask |= mask &gt;&gt; <span class="hljs-number">16</span>;    <br>    <span class="hljs-keyword">return</span> (mask ^ num);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>Leetcode 693 Binary Number with Alternating Bits 判断一个数的位级表示是否不会出现连续的 0 和 1</strong></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">Input: 10<br>Output: True<br>Explanation:<br>The binary representation of 10 is: 1010.<br><br>Input: 11<br>Output: False<br>Explanation:<br>The binary representation of 11 is: 1011.<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 对于 1010 这种位级表示的数，把它向右移动 1 位得到 101，这两个数每个位都不同，因此异或得到的结果为 1111。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasAlternatingBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <br>    <span class="hljs-keyword">int</span> a = (n ^ (n &gt;&gt; <span class="hljs-number">1</span>));    <br>    <span class="hljs-keyword">return</span> (a &amp; (a + <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li><strong>Leetcode 338 Counting Bits 统计从 0 ~ n 每个数的二进制表示中 1 的个数</strong></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">示例1：    <br>输入: 2    <br>输出: [0,1,1]<br>示例2：    <br>输入: 5    <br>输出: [0,1,1,2,1,2]<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*自己的版本，其实都想到这里了，就更进一步就行</span><br><span class="hljs-comment">题目要求：给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？</span><br><span class="hljs-comment">要求算法的空间复杂度为O(n)。</span><br><span class="hljs-comment">你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] countBits(<span class="hljs-keyword">int</span> num) &#123;        <br>    <span class="hljs-keyword">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num + <span class="hljs-number">1</span>];        <br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <br>    <span class="hljs-keyword">int</span> i;        <br>    <span class="hljs-comment">// 执行用时超过99.95%的用户，内存超过53.87%的用户        </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= num; j++)&#123;            <br>        i = j;            <br>        <span class="hljs-comment">// 从这里得出教训，不要轻易对判断循环的变量进行修改，很容易死循环            </span><br>        <span class="hljs-keyword">while</span>(i != <span class="hljs-number">0</span>)&#123;                <br>            i &amp;= (i-<span class="hljs-number">1</span>);                <br>            count++;            <br>        &#125;            <br>        nums[j] = count;            <br>        count = <span class="hljs-number">0</span>;        <br>    &#125;        <br>    <span class="hljs-keyword">return</span> nums;    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 执行用时超过99.95%的用户，内存超过53.87%的用户，跟自己写的版本速度一样，尴尬，但是符合题目要求</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] countBits(<span class="hljs-keyword">int</span> num) &#123;    <br>    <span class="hljs-keyword">int</span>[] ret = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num + <span class="hljs-number">1</span>];    <br>    <span class="hljs-comment">// 注意从i = 1 开始    </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++)&#123;        <br>        <span class="hljs-comment">// 例如6（110） = 4（100）+ 2（10）        </span><br>        <span class="hljs-comment">// i&amp;(i-1) 刚好去掉一个1，那么就加一个1就好啦。因为0的结果在初始化数组就设为0了，作为初始值就可以推出1的，然后推出2的，依次类推        </span><br>        ret[i] = ret[i&amp;(i-<span class="hljs-number">1</span>)] + <span class="hljs-number">1</span>;    <br>    &#125;    <br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>本章主要参考JavaGuide文章  <a href="http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E4%BD%8D%E8%BF%90%E7%AE%97.html#_0-%E5%8E%9F%E7%90%86">Leetcode 题解-位运算</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>DataStructure</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
